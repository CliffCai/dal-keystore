/*
   Copyright 2018 Intel Corporation

   This software is licensed to you in accordance
   with the agreement between you and Intel Corporation.

   Alternatively, you can use this file in compliance
   with the Apache license, Version 2.


   Apache License, Version 2.0

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#ifndef IAS_KEYSTORE_H
#define IAS_KEYSTORE_H

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdint.h>
#include <unistd.h>

#include "keystore_api_common.h"

/**
 * @brief Helper function, provides a local memcpy interface
 *
 * @param[in] dst Destination pointer
 * @param[in] src Source pointer
 * @param[in] size Number of bytes to copy
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int keystore_memcpy(void* dst, const void* src, unsigned int size);

/**
 * @brief Set the keystore device path
 * @param dev_name Path to the device
 *
 * Sets the path of the keystore device. By default this path is
 * set to /dev/keystore and should only need to be changed for
 * testing or debugging.
 *
 */
void ias_keystore_set_device(const char* dev_name);

/**
 * @brief Register a keystore client
 * @param [in] seed_type Which SEED to use to generate client wrapping keys.
 *                       This can be either a device or user-specific seed.
 *                       (SEED_TYPE_DEVICE or SEED_TYPE_USER respectively).
 * @param [out] client_ticket Output buffer for the client ticket
 *                       The caller must assure that at least
 *                       KEYSTORE_CLIENT_TICKET_SIZE bytes are available.
 *
 * Register a client with Keystore. The client is identified using the
 * path of the calling function for user-space applications.
 * A client key is generated by combining the SEED type and client ID.
 * A random ticket is generated and returned to the caller which can be used
 * for subsequent interactions with keystore.
 *
 * The seed type should be chosen depending on the type of data which
 * will be encrypted by this client. Device clients are assumed to process
 * data associated to the device itself, which will not change between users.
 * A user client will encrypt data associated with a user of the device.
 * Examples could be WiFi passwords or phonebook entries. The user can
 * reset the user SEED if requested, which will render unreadable any
 * data encrypted with the previous SEED.
 *
 * An application can register multiple sessions using different SEED types
 * if required. The maximum number of simultaneous sessions available
 * (across multiple applications) is limited in the kernel to KEYSTORE_CLIENTS_MAX
 * (= 256). This limitation is imposed to prevent denial of service attacks.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_register_client(enum keystore_seed_type seed_type, uint8_t *client_ticket);

/**
 * @brief Unregister a Keystore Client
 * @param [in] client_ticket The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 *
 * Unregister a client with keystore. This will remove all state information
 * associated to the client.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_unregister_client(const uint8_t *client_ticket);

/**
 * @brief Get the wrapped key size in bytes
 * @param [in] key_spec     The key type
 * @param [out] wrapped_key_size Size of the wrapped key.
 * @param [out] unwrapped_key_size Size of the unwrapped key.
 *
 * To be called before generate/import key to allocate space for
 * a wrapped key buffer. Either output pointer can be
 * null if only one size is required.
 */
int ias_keystore_wrapped_key_size(enum keystore_key_spec key_spec,
                                  size_t *wrapped_key_size,
                                  size_t *unwrapped_key_size);

/**
 * @brief Generate a random key and wrap it.
 *
 * @param [in] client_ticket The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes)
 * @param [out] keyspec       The type of key to be generated.
 * @param [out] wrapped_key   Output buffer for the wrapped key
 *                 Caller must ensure that the buffer has sufficient
 *                 space by calling keystore_wrapped_key_size beforehand.
 *
 * Generates a random cryptographic key and wraps it using the client key
 * corresponding to the client ticket provided.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_generate_key(const uint8_t *client_ticket,
                              enum keystore_key_spec keyspec,
                              uint8_t *wrapped_key);

/**
 * @brief Wrap the application key.
 *
 * @param [in] client_ticket The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @param [in] app_key       The application key to be wrapped.
 * @param [in] app_key_size  The application key size in bytes.
 * @param [in] keyspec       The key specification.
 * @param [out] wrapped_key   Output buffer for the wrapped key.
 *
 * Wrap (import) a bare (unencrypted) application key which has the given
 * keyspec. The wrapped key is returned to the client for use with keystore
 * for encryption/decryption operations.
 *
 * The expected @p app_key length can be found by calling ias_keystore_wrapped_key_size().
 * The input format of @app_key depends on the value of @p keyspec:
 *
 * - KEYSPEC_LENGTH_128: The key is a byte-array 16 bytes in length.
 * - KEYSPEC_LENGTH_256: The key is a byte-array 32 bytes in length.
 * - KEYSPEC_LENGTH_ECC_PAIR: The key is a struct ias_keystore_ecc_keypair.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_wrap_key(const uint8_t *client_ticket,
                          const uint8_t *app_key, size_t app_key_size,
                          enum keystore_key_spec key_spec,
                          uint8_t *wrapped_key);

/**
 * @brief Unwrap the application key and store in a slot.
 *
 * @param [in] client_ticket     The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @param [in,out] wrapped_key   The wrapped key to be imported.
 * @param [in] wrapped_key_size  The wrapped key size in bytes.
 * @param [out] slot_id           Slot ID where the key is stored.
 *
 * Keystore will take the wrapped key, unwrap it in the kernel and
 * store it in a slot associated with the client_ticket.
 *
 * The number of slots available is limited to KEYSTORE_SLOTS_MAX (= 256)
 * slots per registered client.
 *
 * This function will first try to unwrap the key using the latest client key
 * available. If this fails, it will try to unwrap using any legacy client
 * keys it can generate (which were created with outdated SVN numbered SEEDs).
 * In this case the function will return -EAGAIN, and replace the @wrapped_key
 * data with a key wrapped with the latest SVN. In this case, the client must
 * replace the wrapped key it had previously stored, and call the function again
 * with this updated key. (As the @wrapped_key contents have changed, the function
 * can be directly called again).
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_load_key(const uint8_t *client_ticket,
                          uint8_t *wrapped_key,
                          size_t wrapped_key_size,
                          uint32_t *slot_id);

/**
 * @brief Remove a key from a slot
 *
 * @param [in] client_ticket The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @param [in] slot_id       The slot ID where the key is stored.
 *
 * If there is a key in the given slot, remove it and free the slot.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_unload_key(const void *client_ticket, uint32_t slot_id);

/**
 * @brief Get the required size of an encrypted buffer.
 * @param [in] algo_spec      The encryption algorithm specification.
 * @param [in] input_size     The size of the plaintext buffer.
 * @param [out] output_size    The size of the output buffer.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_encrypt_size(enum keystore_algo_spec algo_spec,
                              size_t input_size, size_t *output_size);
/**
 * @brief Encrypt plaintext using AppKey/IV according to AlgoSpec.
 *
 * @param [in] client_ticket   The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @param [in] slot_id         The slot ID.
 * @param [in] algo_spec       The algorithm specification.
 * @param [in] iv              Encryption initialization vector.
 * @param [in] iv_size         Initialization vector size in bytes.
 * @param [in] input           Input block of data to encrypt.
 * @param [in] input_size      Input block size in bytes.
 * @param [out] output         Pointer to the block for encrypted data. The caller
 *                             is responsible for providing a buffer of sufficent size
 *                             by first calling keystore_encrypt_size.
 *
 * Use the key stored in the given slot to encrypt a block of data.
 *
 * The format of the encrypted @p output depends on the value of @p algo_spec:
 *
 * - ALGOSPEC_AES_CCM, ALGOSPEC_AES_GCM: The output is formatted as
 *   (cyphertext || tag), where cyphertext is the encrypted message
 *   with the same length as @p input, and the tag is the message
 *   authentication tag.
 * - ALGOSPEC_ECIES: The output is formatted as: (H || DH || MAC || cyphertext).
 *   Here H is a 16 byte header, DH is the Diffie-Hillman public key, MAC
 *   is the message digest. ALGOSPEC_ECIES uses ECC curve secp521r1 with
 *   the KDF_x963 key derivation function, an XOR symmetric cypher and
 *   HMAC-SHA256 for message authentication.
 *
 * The format of the @p iv also depends on @p algo_spec:
 *
 * - ALGOSPEC_AES_CCM: The @p iv must be formatted according to RFC3610. The first byte
 *   of the IV contains a series of flags = 64 * Adata * M' + L', where:
 *   - Adata = 0 if l(a) = 0, 1 otherwise (length of authentication data)
 *   - M' = (M-2)/2 (M is authentication length in bytes)
 *   - L' = L - 1   (IV length in bytes)
 *   For example: with no additional data, a 2-byte auth field and 2-byte IV,
 *   @p @iv[0] = 1.
 * - ALGOSPEC_AES_GCM: The @p iv must be formatted according to RFC5288.
 * - ALGOSPEC_ECIES: The @p iv must be set to null with @iv_size zero.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_encrypt(const uint8_t *client_ticket, uint32_t slot_id,
                         enum keystore_algo_spec algo_spec,
                         const uint8_t *iv, size_t iv_size,
                         const uint8_t *input, size_t input_size,
                         uint8_t *output);

/**
 * @brief Get the required size of an encrypted buffer.
 * @param [in] algo_spec      The encryption algorithm specification.
 * @param [in] input_size     The size of the encrypted buffer.
 * @param [out] output_size    The size of the output buffer.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_decrypt_size(enum keystore_algo_spec algo_spec,
                              size_t input_size, size_t *output_size);

/**
 * @brief Decrypt cipher using AppKey and AlgoSpec/IV.
 *
 * @param [in] client_ticket  The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @param [in] slot_id        The slot ID.
 * @param [in] algo_spec       The algorithm specification.
 * @param [in] iv              Encryption initialization vector.
 * @param [in] iv_size         Initialization vector size in bytes.
 * @param [in] input          Input block of data to decrypt.
 * @param [in] input_size     Input block size in bytes.
 * @param [out] output         Pointer to the block for decrypted data. The caller
 *                  must ensure sufficient space is available for the
 *                  decrypted data by calling keystore_decrypt_size
 *                  first.
 *
 * Use the key stored in the given slot to decrypt a block of data.
 *
 * @return 0 if OK or negative error code (see errno.h).
 */
int ias_keystore_decrypt(const uint8_t *client_ticket, uint32_t slot_id,
                         enum keystore_algo_spec algo_spec,
                         const uint8_t *iv, size_t iv_size,
                         const uint8_t *input, size_t input_size,
                         uint8_t *output);

#ifdef __cplusplus
}
#endif

#endif  // IAS_SECURITY_KEYSTORE_LIB_HPP
